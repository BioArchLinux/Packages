<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-09-24 Sa 13:28 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>ExaBayes User's Manual</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="for support, please contact exabayes-at-googlegroups-dot-com" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/org.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">ExaBayes User's Manual</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. Quick Start</a></li>
<li><a href="#orgheadline2">2. Scope of ExaBayes: What is it? What is it not?</a></li>
<li><a href="#orgheadline9">3. Installation</a>
<ul>
<li><a href="#orgheadline3">3.1. Executing downloaded executables</a></li>
<li><a href="#comp-src">3.2. Compiling ExaBayes from source</a></li>
<li><a href="#orgheadline8">3.3. Installation of ExaBayes Into File Systems</a></li>
</ul>
</li>
<li><a href="#orgheadline12">4. Tutorial and Workflow</a>
<ul>
<li><a href="#orgheadline10">4.1. Basic Workflow</a></li>
<li><a href="#orgheadline11">4.2. Partitioned Alignment</a></li>
</ul>
</li>
<li><a href="#orgheadline15">5. Command Line Options</a>
<ul>
<li><a href="#orgheadline13">5.1. Mandatory Arguments</a></li>
<li><a href="#orgheadline14">5.2. Optional Arguments</a></li>
</ul>
</li>
<li><a href="#config">6. Configuration File</a>
<ul>
<li><a href="#param-block">6.1. Declaring and Linking Parameters</a></li>
<li><a href="#orgheadline23">6.2. Declaring Priors for Parameters</a></li>
<li><a href="#orgheadline27">6.3. Configuring the Run</a></li>
<li><a href="#proposal-config">6.4. Configuring Proposals</a></li>
</ul>
</li>
<li><a href="#prepost">7. Pre-/post-processing utilities</a>
<ul>
<li><a href="#parser">7.1. parser</a></li>
<li><a href="#parser">7.2. postProcParam</a></li>
<li><a href="#orgheadline32">7.3. sdsf</a></li>
<li><a href="#orgheadline33">7.4. credibleSet</a></li>
<li><a href="#orgheadline34">7.5. extractBips</a></li>
<li><a href="#orgheadline35">7.6. consense</a></li>
</ul>
</li>
<li><a href="#cluster">8. ExaBayes on Clusters/Supercomputers</a>
<ul>
<li><a href="#orgheadline37">8.1. TL;DR summary</a></li>
<li><a href="#right-parallelism">8.2. Choosing the right kind of parallelism</a></li>
<li><a href="#memory">8.3. Saving Memory</a></li>
<li><a href="#orgheadline43">8.4. Highly Partitioned Runs</a></li>
<li><a href="#reproducibility">8.5. Note on Reproducibility</a></li>
</ul>
</li>
<li><a href="#partitionfile">9. File Format: Model/Partitioning file</a></li>
<li><a href="#orgheadline47">10. Trading mixing efficiency versus runtime</a></li>
<li><a href="#orgheadline48">11. Citation</a></li>
<li><a href="#orgheadline49">12. References</a></li>
</ul>
</div>
</div>
<img src="./img/banner2.png" width="100%" alt="some_text">

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> Quick Start</h2>
<div class="outline-text-2" id="text-1">
<p>
Installation of <code>ExaBayes</code> requires basic proficiency with using a
terminal (for help, consider this <a href="https://help.ubuntu.com/community/UsingTheTerminal">tutorial</a>).
</p>

<p>
For impatient users who want to give <code>ExaBayes</code> a quick try, we
recommend:
</p>

<ol class="org-ol">
<li>Download and unpack the software package. You find executables
(sequential: <code>yggdrasil</code>, parallel: <code>exabayes</code>) in the <code>./bin</code>
folder. The <code>-h</code> flag provides you with an overview of
options. If you downloaded the source code please follow the
instructions in Sect. <a href="#comp-src">3.2</a>.</li>
<li>If you have convinced yourself, that the executables are in
place, consider running the examples in the <code>./examples</code>
directory (call the <code>./call.sh</code> or <code>./call-parallel.sh</code> scripts
there).  If you want to run your own dataset, convert your
alignment file into phylip-format (e.g., using <code>seaview</code>).</li>
<li><p>
If you have prepared your dataset, run the sequential version of
ExaBayes, where alignmentFile.phy is the alignment file (use -m
PROT for protein data) and <code>$RANDOM</code> could be any random number
seed.
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./bin/bin/yggdrasil -f alignmentFile.phy -m DNA -s $RANDOM
</pre>
</div></li>
<li>After some time, ExaBayes should finish or you may abort at any
time. You can now examine the two output files ExaBayes_topology*
and ExaBayes_parameters* using the post-processing tools
<code>consense</code>, <code>postProcParam</code>, <code>credibleSet</code> and <code>extractBips</code> (see
Sect. <a href="#prepost">7</a>). Call the respective programs with <code>-h</code> for an
overview of functions.</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> Scope of ExaBayes: What is it? What is it not?</h2>
<div class="outline-text-2" id="text-2">
<p>
ExaBayes is a tool for Bayesian phylogenetic analyses.  It
implements a Markov chain Monte Carlo sampling approach that allows
to determine the posterior probability of a tree (resp., topology)
and various evolutionary model parameters, for instance, branch
lengths or substitution rates.  Similar approaches are implemented
in <a href="http://beast.bio.ed.ac.uk/">BEAST</a> \cite{Drummond2012} or <a href="http://mrbayes.sourceforge.net/">MrBayes</a>
\cite{Ronquist2012}. ExaBayes has heavily drawn inspiration
specifically from the latter one.
</p>

<p>
ExaBayes comes with the most commonly used evolutionary models, such
as the generalized time reversible model (GTR) of character
substitution, the discretized \(\Gamma\) model of among site rate
heterogeneity and estimates trees with unconstrained branch
lengths. For clocked tree models or less parameter-rich substitution
models, we refer you to the established tools.
</p>

<p>
The distinguishing feature of ExaBayes is its capability to handle
enormous datasets efficiently. ExaBayes provides an implementation
of data parallelism using the <i>Message Passing Interface</i>
(MPI). This means, that if you conduct your analysis on a computing
cluster composed of several machines (a.k.a. nodes), the memory
needed to evaluate the likelihood of trees and parameters given a
large alignment can be spread out across multiple computing
nodes. In conclusion, the size of the concatenated alignment
ExaBayes can handle is only limited by the combined main memory of
your entire computing cluster.
</p>

<p>
Aside from that ExaBayes also implements 
</p>
<ul class="org-ul">
<li>chain-level and run-level parallelism,</li>
<li>techniques to trade runtime for reduced memory footprint,</li>
<li>a subtree equality vector approach that reduces memory without
loss of runtime,</li>
<li>a native AVX implementation for evaluating likelihood and
parsimony scores (i.e., ExaBayes makes full use of your
cutting-edge CPU),</li>
<li>techniques to efficiently handle an arbitrary number of
partitions.</li>
</ul>


<p>
We use the highly efficient parsimony and likelihood implementation
of RAxML \cite{Stamatakis2006}. Many of the techniques described
above are adapted from or inspired by our experiences with
large-scale maximum likelihood inferences using RAxML-Light/ExaML
\cite{Stamatakis2012,Stamatakis2012a}.
</p>

<p>
The ExaBayes package contains all tools necessary for
post-processing your sampled chains. For visualization of parameter
distributions, we recommend <a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a> and <a href="http://tree.bio.ed.ac.uk/software/figtree/">FigTree</a> (for which ExaBayes
parameter files are compatible).
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><span class="section-number-2">3</span> Installation</h2>
<div class="outline-text-2" id="text-3">
<p>
For ExaBayes, we provide pre-compiled binaries that run on a wide
range of systems (limited to Linux and MacOS though, we will not be
able to support Windows in the foreseeable future). For optimal
efficiency or if you want to use the parallel version, it is highly
recommendable to compile ExaBayes from source. This should be
straight-forward on a computer center, requires a bit of work on a
Linux system and unfortunately is not entirely trivial if you have
a MacOS system and no experience with the command line.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">3.1</span> Executing downloaded executables</h3>
<div class="outline-text-3" id="text-3-1">
<p>
After you have downloaded the appropriate package, you find all
executables in the <code>./bin</code> folder. Just execute these only using
the <code>-h</code> flag and you will be given a help page. If the executables
produce error messages (indicating that some library was not
found), you either downloaded the wrong package or you have to
compile from source.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="comp-src"><a id="orgheadline7"></a><span class="section-number-3">3.2</span> Compiling ExaBayes from source</h3>
<div class="outline-text-3" id="text-comp-src">
<p>
Download and extract the source archive (sources are also included
in all binary distributions). 
</p>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">3.2.1</span> Prerequisites for Linux systems</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
ExaBayes requires a relatively recent <code>c/c++</code> compiler that
supports <code>c++11</code> features. ExaBayes is confirmed to work with (only
one required):
</p>
<ol class="org-ol">
<li>GCC, version 4.6 or greater</li>
<li>Clang, version 3.2 or greater</li>
</ol>

<p>
For running ExaBayes in parallel using more than one computing
node, you need a working MPI installation. If you want to make most
of your local multi-core machine (e.g., laptop), simply install
OpenMPI or Mpich2. On Debian/Ubuntu, this should be as simple as
(choose one):
</p>
<div class="org-src-container">

<pre class="src src-bash">$ sudo apt-get install mpich2 libmpich2-dev
$ sudo apt-get install openmpi-bin libopenmpi-dev
</pre>
</div>

<p>
For checking, if MPI already is installed on your machine, try to
enter <code>mpirun</code> or <code>mpiexec</code> in a terminal. If it is not installed,
you will receive a message "command not found".
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="apple"><a id="orgheadline5"></a><span class="section-number-4">3.2.2</span> Prerequisites for Mac OS X</h4>
<div class="outline-text-4" id="text-apple">
<p>
For installation on an Apple system, you ideally should have set up
an environment that allows you to compile (MPI-)applications in the
terminal.
</p>

<p>
First, you need to download and install <a href="https://developer.apple.com/technologies/tools/">Xcode</a> (also available in
the AppStore) and <a href="http://www.macports.org/">MacPorts</a>. You only need MacPorts, if you want to
build the parallel version. Open a terminal and use MacPorts to
install an MPI implementation (either openmpi or mpich2):
</p>
<div class="org-src-container">

<pre class="src src-bash">$ sudo port install openmpi-default
$ sudo port install mpich-default
</pre>
</div>

<p>
After the installation, a message will suggest that you set the MPI
installation as default. You now have MPI compiler wrappers
available (mpicc-mpich-mp, mpicxx-mpich-mp <i>or</i> mpicc-mpich-mp,
mpicxx-mpich-mp <i>or</i> mpicc, mpicxx).
</p>

<p>
For installing MPI, also consider <a href="http://brew.sh/">HomeBrew</a> which is an alternative
to MacPorts that does not require <code>sudo</code>. 
</p>
</div>
</div>


<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">3.2.3</span> Configuring and Compiling</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
ExaBayes uses the typical autotools setup. Typically, the MPI
environment (if available) or best vectorization scheme (SSE or
AVX) is determined automatically. The basic command for building
exabayes (with MPI support) is
</p>

<div class="org-src-container">

<pre class="src src-bash">./configure --enable-mpi &amp;&amp; make
</pre>
</div>

<p>
Consider the following options:
</p>

<ul class="org-ul">
<li>important: use the &#x2013;bindir option with the absolute path to a
directory in conjunction with "make install" to dump all executables
into a folder /full/path/to/this/dir/bin</li>
</ul>

<div class="org-src-container">

<pre class="src src-bash">./configure --bindir=/full/path/to/this/dir &amp;&amp; make install
</pre>
</div>

<ul class="org-ul">
<li>omit "&#x2013;enable-mpi" to only build the multi-threaded version
(e.g., if you have no MPI support available)</li>

<li>for the build on Mac systems, it <b>may</b> be necessary to add
CXXFLAGS="-stdlib=libc++" at the configure step:</li>
</ul>
<div class="org-src-container">

<pre class="src src-bash">./configure CXXFLAGS="-stdlib=libc++" &amp;&amp; make
</pre>
</div>

<ul class="org-ul">
<li>use the ./configure environment variables (see ./configure &#x2013;help)
to specify non-default compilers, for instance</li>
</ul>

<div class="org-src-container">

<pre class="src src-bash">./configure --enable-mpi CC=clang-3.3 CXX=clang++-3.3 MPICXX=mpicxx.openmpi
</pre>
</div>

<p>
will configure exabayes to be build with clang-3.3 and OpenMPI,
although default compilers of your system are &#x2013; for instance &#x2013; gcc
and MPICH.
</p>

<p>
Once everything has compiled, check, if all binaries are there as expected: 
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ls bin
     consense        credibleSet     exabayes        extractBips     parser          postProcParam   sdsf            yggdrasil
</pre>
</div>

<p>
Please notice: 
</p>

<ol class="org-ol">
<li>Compilation takes a while: if you have multiple cores available,
then use "make -j x", where x is the number of cores you want to
use for compilation.</li>

<li>If for some reason you want to re-compile the code, do not forget
to run "make clean" first.</li>

<li>If you compile on a cluster where your login-node has an
AVX-capable CPU, then you will get an AVX-optimized exabayes. If
you now try to execute this version of exabayes on a non-AVX
capable CPU, the program mostly will just crash with the message
"Illegal instruction.". In these cases, compile exabayes on one
of the nodes you intend to execute ExaBayes later <b>or</b> use the
configure flags "&#x2013;disable-avx", etc.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">3.3</span> Installation of ExaBayes Into File Systems</h3>
<div class="outline-text-3" id="text-3-3">
<p>
So far we have compiled the executables. The build system offers
the capability to install compiled binaries and documentation into
defined places (e.g., ~/usr, /usr/local, /opt).
</p>

<p>
In order to achieve this, you need to specify an absolute path as
"&#x2013;prefix" and invoke "make &#x2013;install" after the successful build:
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./configure --prefix=/home/user/usr &amp;&amp; make &amp;&amp; make --install
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><span class="section-number-2">4</span> Tutorial and Workflow</h2>
<div class="outline-text-2" id="text-4">
<p>
This is a basic tutorial for how to conduct Bayesian tree inference
with <code>ExaBayes</code> (specifically useful, if you do not have much
experience with Bayesian tree inference).
</p>

<p>
Assume you want to analyze an alignment file that contains several
partitions. Create a folder and copy <code>aln.phy</code> and <code>aln.part</code> from
the folder <code>examples/dna-partitioned</code> into that folder. Copy
<code>./examples/configFile-all-options.nex</code> as well and rename it to
<code>config.nex</code>. We will assume that all executables are in this
working folder (otherwise, modify the path to the executable
accordingly).
</p>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">4.1</span> Basic Workflow</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Let's at first simply run a single chain for some time: 
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./yggdrasil -f aln.phy -m DNA -n myRun -s $RANDOM
</pre>
</div>

<p>
<code>ExaBayes</code> will print output that is separated into various sections: 
</p>
<ol class="org-ol">
<li>after the header, you find a section (divided by '=') that
re-iterates the alignment (number of unique patterns and type
of partitions).</li>
<li>In the next section, <code>ExaBayes</code> lists the parameters to be
integrated. For instance, the tree topology is considered a
parameter. It also displays the (default) prior for parameters
and initial values.</li>
<li>The \(3^{rd}\) section contains the proposals that are
instantiated for integrating over the aforementioned
parameters.</li>
</ol>

<p>
During the MCMC simulation, ExaBayes prints the log-likelihoods
(lnl) of the (sole) chain. You'll find that after some time the lnl
will reach a plateau.  Stop the run after something like 50,000
generations (using Control-c).
</p>

<p>
Now examine the output files created by ExaBayes (we neglect the
binary alignment file and the checkpoint files):
</p>
<ul class="org-ul">
<li>ExaBayes_info.myRun <br  />
Contains the same information also printed to the screen.</li>
<li>ExaBayes_topologies.myRun.0 <br  />
Contains all sampled topologies in nexus format.</li>
<li>ExaBayes_parameters.myRun.0 <br  />
Contains values sampled for all non-topological, non-branch length
values.</li>
<li>ExaBayes_diagnostics.myRun <br  />
Contains chain diagnostics (e.g., acceptance ratios for all
proposals or topological convergence in form of asdsf).</li>
</ul>

<p>
Now use the post-processing tools to examine the result. First, we
create a consensus tree:
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./consense -f ExaBayes_topologies.myRun.0 -n myCons
</pre>
</div>

<p>
Now, open a tree viewer of your choice (e.g., FigTree, Archaeopteryx
or Dendroscope) and have a look at the consensus tree. If you ran
just 50,000 generations, you will probably find the confidence in
most branches is pretty low.
</p>

<p>
Let's inspect the \(50\%\) credible set of trees: 
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./credibleSet -f ExaBayes_topologies.myRun.0 -n cred
</pre>
</div>

<p>
The output file <code>ExaBayes_credibleSet.tmp</code> contains all sampled
trees ordered by the frequency of their occurrence. You probably
will find that no tree occurred more than once.
</p>

<p>
Finally, let's check, how well the parameters are sampled: 
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./postProcParam   -f ExaBayes_parameters.myRun.0  -n params
</pre>
</div>

<p>
Alternatively, you could also open the parameter file with
<code>Tracer</code> and visualize the distributions. If you do not have
<code>Tracer</code> installed, have a look at
<code>ExaBayes_parameterStatistics.params</code> (spreadsheet tools like
Excel are helpful). You'll find summary statistics for each
parameter. Specifically, check out the effective sampling size
(ESS) value for each parameter. Since samples in a chain are
correlated, they are less informative, than if you had drawn the
values independently from the original distribution. The ESS of
samples indicates the number of samples your samples corresponds
to, if they were drawn independently.
</p>

<p>
You will find that most ESS values are in the range between 30
and 80. This is not bad for the low number of generations, but to
assure that each parameter has been sampled adequately, values
should be \(>100\) or even better \(>200\). High ESS values indicate
that your chain has explored this parameter sufficiently.
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">4.2</span> Partitioned Alignment</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now remove the files from the initial run (otherwise ExaBayes will
complain). We will now conduct a proper analysis using several
chains on a partitioned alignment. 
</p>

<p>
You have to modify <code>config.nex</code> (remove the square brackets to
uncomment). Uncomment <code>numGens</code> and set it to 100000 (or
1e5). Uncomment <code>numRuns</code> and set it to 4. This means that
<code>ExaBayes</code> will conduct 4 independent analysis (starting in 4
different random trees). If all runs yield the same split
frequencies (i.e., the same confidence in a split), we can be
relatively sure that we have sampled the topology parameter
sufficiently (while it is still possible that simply all 4 chains
got stuck in the same local optimum).
</p>

<p>
Check out the partitions file (<code>aln.part</code>): it contains 4
partitions. By default, ExaBayes assumes that partitions have
distinct branch lengths. Let's link all partitions into a single
branch length parameter. To do so, add "<code>brlens = (0-3)</code>" in the
<code>params</code> section.
</p>

<p>
Use this command line to start the analysis:   
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ./yggdrasil -f aln.phy -q aln.part  -n myRun -s $RANDOM -c config.nex
</pre>
</div>

<p>
By default, ExaBayes will compute the average standard deviation of
split frequencies (asdsf) every 5,000 generations and stops the
analysis once it the asdsf is better than \(5\%\) (and once we have at
least 100,000 generations for each chain).
</p>

<p>
The analysis may take a while. If you have a cluster (with for
instance 16 cores) at your disposal, consider running the parallel
version:
</p>

<div class="org-src-container">

<pre class="src src-bash">$ mpirun -np 16  ./exabayes -f aln.phy -q aln.part  -n myRun -s $RANDOM -c config.nex -R 4
</pre>
</div>
<p>
With <code>-R 4</code>, ExaBayes runs all 4 chains in parallel. In an
additional section, ExaBayes will inform you which chains and how
many unique site patterns are assigned to each process.
</p>

<p>
You will notice after 100,000 generations, that the 4 chains
converge rather slowly. Thus, enable Metropolis-Coupling to speed
up the convergence. Set <code>numCoupledChains</code> to 2 and (for purely
computational reasons in this example), reduce the <code>numRuns</code>
to 2. Also, set <code>parsimonyStart</code> to true, such that your chains
start from a parsimony tree instead of a random tree. Using
parsimony trees as initial topologies saves you some time, however
theoretically it also increases the probability that all your
independent chains become stuck in the same local optimum and you
obtain incorrect estimates for posterior probabilities.
</p>

<p>
If you have many cores, to run the two independent runs as well as
the coupled chains in parallel:
</p>

<div class="org-src-container">

<pre class="src src-bash">$ mpirun -np 16 ./exabayes -f aln.phy -q aln.part -n myRun -s $RANDOM -c config.nex -R 2 -C 2
</pre>
</div>
<p>
After \(\approx\) 150,000 generations, the ASDSF should have fallen
below \(5\%\), which is acceptable. A look at the consensus tree
reveals that this dataset in fact contains several low confidence
branches. While in the first run the reason for low confidence
branches was due to the low number of generations, we can be more
certain now that that low confidence branches are a result of the
phylogenetic signal in the alignment. Since you ran 2 independent
analyses, you obtain 2 sets of output files (parameter and
topologies). You can feed both files into the consensus tree (for
both files the initial \(25\%\) of samples will be discarded).
</p>

<div class="org-src-container">

<pre class="src src-bash">$ ./consense -f ExaBayes_topologies.myRun.* -n myCons
</pre>
</div>

<p>
Analyze both parameter files using
</p>

<div class="org-src-container">

<pre class="src src-bash">$ ./postProcParam -f ExaBayes_parameters.myRun.* -n params
</pre>
</div>

<p>
Since we carried out two partitioned analyses, we have a larger
number of parameters (where e.g., <code>r{2}(C&lt;-&gt;T)</code> is the substitution
probability of C to T in the third partition). We find that nearly
all parameters have an ESS \(> 100\). The final column now contains
the potential scale reduction factor (PSRF). It indicates, whether
within-chain variance (of a parameter) is similar to between-chain
variance. For this convergence statistic, values should be close to
1, but lower than 1.2 or 1.1 (probably the case after 150,000
generations).
</p>

<p>
So far, we have neglected the branch length parameter. You may
already have noticed, that the consensus tree has been annotated
with branch lengths. To extract ESS and PSRF values for each branch
length, run: 
</p>

<div class="org-src-container">

<pre class="src src-bash">$ ./extractBips -f ExaBayes_topologies.myRun.* -n bls
</pre>
</div>

<p>
Thus, you obtain the following files: 
</p>
<ul class="org-ul">
<li>ExaBayes_bipartitions.tmp <br  />
contains an identifier for each branch/split (that is explicitly printed)</li>
<li>ExaBayes_fileNames.tmp <br  />
lists the file names used as input (and assigned an id to them)</li>
<li>ExaBayes_bipartitionBranchLengths.tmp <br  />
contains all raw branch lengths sampled and lists split id and
file ids</li>
<li>ExaBayes_bipartitionStatistics.tmp <br  />
contains statistics for each branch (specifically the ESS and PSRF)</li>
</ul>

<p>
Notice that for low confidence branches you are likely to encounter
poor ESS/PSRF values. This means that you substantially have to
increase the number of generations in order to obtain accurate
estimates of branch lengths distributions.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">5</span> Command Line Options</h2>
<div class="outline-text-2" id="text-5">
<p>
Command line options specify, <b>how</b> ExaBayes will carry out the
analyses. In contrast, the a config file specifies which kind of
analyses will be executed. 
</p>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">5.1</span> Mandatory Arguments</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li><p>
<b>-f alignmentFile</b> 
</p>

<p>
provides an alignment file. If this file is the binary output
produced by <code>parser</code> (see Section <a href="#parser">7.1</a>), then no further
arguments are required.  If you provide a plain (un-processed)
<a href="http://evolution.genetics.washington.edu/phylip/doc/sequence.html">Phylip file</a>, then either <code>-m</code> (single partition model) or <code>-q</code>
(model file) are mandatory.
</p></li>

<li><p>
<b>-m DNA | PROT</b> 
</p>

<p>
specifies the data type used, when a
Phylip-formatted alignment has been passed via <code>-f</code>. This way, the
alignment is parsed as a single partition with either DNA or amino
acid (<code>PROT</code>) data.
</p></li>

<li><p>
<b>-q modelFile</b> 
</p>

<p>
specifies a raxml-style partitioning/model scheme
for the alignment. For this option, a Phylip-formatted alignment
must be passed via <code>-f</code>. See Section <a href="#partitionfile">9</a> for a description of
the file format. 
</p></li>

<li><p>
<b>-s seed</b> 
</p>

<p>
provides a random seed. This number makes the run
reproducible. The same seed, data set configuration file will
result in the exact same result (apart from limitations given in
Section <a href="#reproducibility">8.5</a>).  If you restart from a checkpoint
file, this option will be ignored.
</p></li>

<li><p>
<b>-n id</b> 
</p>

<p>
provides a run id used for naming output files 
</p></li>

<li><p>
<b>-r runid</b> 
</p>

<p>
restarts your run from a previous run id. If your previous
ExaBayes-run did not finish (because of a manual abort or
walltime restrictions), this option can be used for continuing
the run. It is essential, that you pass the same configuration
and alignment file. Some adaptions to the configuration file are
possible (e.g., larger number of generations to be run, lower
topological convergence threshold). Furthermore, all files that
carry the previous runid in their name must be located in the
current folder.
</p>

<p>
Example:
</p>
<div class="org-src-container">

<pre class="src src-bash">$ mpirun -np 8 ./exabayes -s $RANDOM -n myId -c myConfig -f myBinaryAlnFile.bin 
$ [runnig....] -&gt; aborted!
$ mpirun -np 2  ./exabayes -r myId -n myIdContinued -c myConfig -f myBinaryAlnFile.bin -S
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">5.2</span> Optional Arguments</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li><p>
<b>-d</b> 
</p>

<p>
carries out a dry-run. Only checks your config and alignment file
and does not compute anything. Very recommendable, before
submitting a large run to a cluster.
</p></li>

<li><p>
<b>-T n</b>
</p>

<p>
Executes Yggdrasil with \(n\) threads. We recommend to use the
multi-threaded version of yggdrasil only on systems, where no MPI
installation is available.
</p></li>

<li><p>
<b>-c configFile</b> 
</p>

<p>
passes a configuration file that specifies how the MCMC will be
carried out (see ./examples/configFile-all-options.nex and
Section <a href="#config">6</a> for details)
</p></li>

<li><p>
<b>-w workDir</b> 
</p>

<p>
specifies a location for output files
</p></li>

<li><p>
<b>-R num</b> 
</p>

<p>
(<code>exabayes</code>-only) specifies the number of runs (i.e., independent
chains) to be executed in parallel. Large runs should be carried
out as separate runs, see Section <a href="#cluster">8</a> for further details.
</p></li>

<li><p>
<b>-C num</b> 
</p>

<p>
(<code>exabayes</code>-only) specifies the number of chains (i.e.,
coupled chains per independent run) to be executed in
parallel. Employing this option may be less efficient in terms of
runtime and memory than data-level parallelism, see Section <a href="#cluster">8</a> for
further details.
</p></li>

<li><p>
<b>-S</b> 
</p>

<p>
try to save memory using the SEV-technique for gap columns on
large gappy alignments Please refer to this <a href="http://www.biomedcentral.com/1471-2105/12/470">paper</a>. On very gappy
alignments this option yields considerable runtime improvements.
</p></li>

<li><p>
<b>-M mode</b> 
</p>

<p>
specifies the memory versus runtime trade-off.  &lt;mode&gt;
is a value between 0 (fastest, highest memory consumption) and 3
(slowest, least memory consumption). See Section <a href="#memory">8.3</a> for details.
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-2">
<h2 id="config"><a id="orgheadline29"></a><span class="section-number-2">6</span> Configuration File</h2>
<div class="outline-text-2" id="text-config">
<p>
In this Section, we describe all available options of the
configuration file in detail. The configuration file is a file in
nexus-format that is divided into sections. See
examples/all-options-documented.nex for a complete version (and
maybe copy and customize this file).  None of the following blocks
in mandatory. The parameter file itself is not mandatory and the
default values mentioned below are used instead. The nexus-syntax
for declaring a block is (here declaring a <code>run</code> block).
</p>

<div class="org-src-container">

<pre class="src src-TEXT">begin run; 
   option value
end;
</pre>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="param-block"><a id="orgheadline16"></a><span class="section-number-3">6.1</span> Declaring and Linking Parameters</h3>
<div class="outline-text-3" id="text-param-block">
<p>
keyword: <code>params</code> 
</p>

<p>
This section allows to declare and link parameters (e.g., branch
lengths) across partitions. You should have declared partitions in
the partition file (passed via <code>-q</code>). If you provided a partition
file to the <code>parser</code> tool, then the binary output file already
contains information about partitions. Partition ids start with 0
and refer to the order provided in the partition file.
</p>

<p>
Currently the following keywords can be used to specify a parameter
linking scheme (keywords are case-insensitive):
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">param</th>
<th scope="col" class="org-left">explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>stateFreq</code></td>
<td class="org-left">link the equilibrium state frequencies (4 for DNA, 20 for AA) for partitions</td>
</tr>

<tr>
<td class="org-left"><code>rateHet</code></td>
<td class="org-left">link the alpha parameter of the \(\Gamma\)  distribution of rate heterogeneity among sites</td>
</tr>

<tr>
<td class="org-left"><code>revMat</code></td>
<td class="org-left">link the substitution rates in the GTR matrix (DNA:6, AA:190) across partitions</td>
</tr>

<tr>
<td class="org-left"><code>brlens</code></td>
<td class="org-left">link branch lengths across partitions</td>
</tr>

<tr>
<td class="org-left"><code>aaModel</code></td>
<td class="org-left">link the fixed rate substitution matrix across partitions (if applicable)</td>
</tr>
</tbody>
</table>

<p>
Note that, by default all parameters are unlinked for all
partitions. Specifically regarding branch lengths, most people only
want one global branch length parameter. If a partition id is
omitted from the scheme, the default behaviour of ExaBayes is to
instantiate a new parameter for this partition (i.e., it is
unlinked).
</p>

<p>
You have the following options for specifying linkage (here
demonstrated for the branch length parameter):
</p>

<ul class="org-ul">
<li>use <i>comma</i> to declare partitions as separate parameters <br  />
example: <code>brlens = (0,1,2,3)</code> <br  />
result: v{0}, v{1}, v{2}, v{3} <br  /></li>

<li>use <i>plus</i> to link two partitions into one parameter <br  />
example: <code>brlens = (0 + 1 , 2 , 3)</code> <br  />
result:  v{0,1}, v{2}, v{3} <br  /></li>

<li>use <i>colon</i> to declare a range of unlinked partitions (each one parameter) <br  />
example: <code>brlens = (0:3)</code> <br  />
result:  v{0}, v{1}, v{2}, v{3}  <br  /></li>

<li>use <i>dash</i> to declare a range partitions linked into one
parameter <br  />
example: <code>brlens = (0-3)</code><br  />
result: v{0,1,2,3} <br  /></li>
</ul>

<p>
For most use cases, you probably will only want to link all branch
lengths. However, in case you work with protein partitions, please
consider:
</p>

<ul class="org-ul">
<li>By default ExaBayes creates one <code>aaModel</code> parameter for each of
your amino acid partitions. As state frequencies, ExaBayes uses
the empirical frequencies provided by the respective amino acid
substitution matrix.</li>
<li>Instead of using the empirical frequencies, you may want to let
ExaBayes integrate over these state frequencies. For doing so, you
simply have to declare one of the respective partitions when
specifying the <code>stateFreq</code> parameter scheme. If you have two AA
partitions, then <code>stateFreq = (0)</code> instructs ExaBayes to integrate
over the state frequencies of the first amino acid model
parameter.</li>
<li>As an alternative to proposing fixed-rate AA substitution matrices
for AA partitions, you can use ExaBayes to integrate over amino
acid GTR matrices (189 free parameters).  For doing so, declare
(and link) the respective AA partitions in the <code>revMat</code> linking
scheme (e.g., <code>revMat = (0+1)</code> for 1 shared GTR matrix across 2 AA
partitions).</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">6.2</span> Declaring Priors for Parameters</h3>
<div class="outline-text-3" id="text-6-2">
<p>
keyword: <code>priors</code>
</p>

<p>
The prior block let's you declare your prior belief regarding the
values of parameters ExaBayes integrates over. This affects
parameters implicitly instantiated by ExaBayes or explicitly
defined in a <code>params</code> block (see Section <a href="#param-block">6.1</a>).
</p>

<p>
By default priors specifications are applied to all matching
parameters. You can overwrite these <i>general</i> priors by specifying
parameter-specific priors. For doing so, list all at least one
partition that is assigned to your target parameter in curly
brackets after the prior keyword. For instance:
</p>
<div class="org-src-container">

<pre class="src src-TEXT">brlenPr exponential(10)
brlenPr{0,2,10} uniform(1e-6,10)
</pre>
</div>
<p>
applies a uniform prior with \([1e-6,10]\) to all branch length
parameters that contain the partitions 0,2 or 10 and applies an
exponential prior with \(\lambda = 10\) to all remaining branch
length parameters.
</p>
</div>

<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17"><span class="section-number-4">6.2.1</span> Topology Prior</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
keyword: <code>topoPr</code>, <br  />
default: <code>topoPr uniform()</code> <br  />
valid values: 
</p>
<ul class="org-ul">
<li><code>fixed()</code> <br  />
topology is kept fixed</li>
<li><code>uniform()</code> <br  />
all topologies have the same prior probability</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18"><span class="section-number-4">6.2.2</span> Branch Lengths Prior</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
keyword: <code>brlenPr</code> , <br  />
default: <code>brlenpr exponential(10)</code><br  />
valid values:
</p>
<ul class="org-ul">
<li><code>exponential(</code> \(\lambda\) <code>)</code> <br  />
exponential prior with parameter \(\lambda\),</li>
<li><code>uniform(start,end)</code> <br  />
uniform probability in the range \([start,end]\) <br  /></li>
<li><code>fixed(</code> \(val\) <code>)</code> <br  />
all branch lengths will be assigned the value \(val\) that is
kept fixed during the analysis</li>
<li><code>fixed()</code> <br  />
all branch lengths keep original branch length provided via a
starting tree. If no starting tree is available, a default
value (currently 0.1) is assigned and kept fix during MCMC
sampling.</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19"><span class="section-number-4">6.2.3</span> Reversible Matrix Prior</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
keyword: <code>revMatPr</code>  <br  />
default: <code>revMatPr dirichlet(1,...,1)</code><br  />
 valid values: 
</p>
<ul class="org-ul">
<li><code>dirichlet(</code> \(x_1,x_2,\ldots, x_n\) <code>)</code><br  />
where for a dirichlet prior \(x_i\) are the substitution rates in
a GTR matrix and thus \(n = 6\) for DNA GTR matrices and \(n =
       190\) (use with care) for AA GTR matrices.<br  /></li>
<li><code>fixed(</code> \(x_1,x_2, \ldots, x_n\) <code>)</code><br  />
fixed rates are assigned to the matrix and kept fix during MCMC
sampling. The values \(x_i\) may be expressed as relative rates
(i.e, ExaBayes will normalize the rates, s.t. they sum up to
1.0)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20"><span class="section-number-4">6.2.4</span> Rate Heterogeneity Prior</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
keyword: <code>shapePr</code>, <br  />
default: <code>shapePr uniform(0,200)</code>  <br  />
valid values: <br  />
</p>
<ul class="org-ul">
<li><code>exponential(</code> \(\lambda\) <code>)</code> <br  />
prior probability of \(\alpha\) values have an exponential
distribution with parameter \(\lambda\)</li>
<li><code>uniform( start, end )</code> <br  />
\(\alpha\) values have uniform prior probability in the range
\([ start, end ]\)</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21"><span class="section-number-4">6.2.5</span> State Frequencies Prior</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
keyword: <code>stateFreqPr</code> , <br  />
default: dirichlet(1,1,\(\ldots\),1)<br  />
valid values: <br  />
</p>
<ul class="org-ul">
<li><code>dirichlet(</code> \(x_1,x_2, \ldots, x_n\) <code>)</code> <br  />
where for a dirichlet prior \(x_i\) are the state frequencies in
a GTR matrix and thus \(n =4\) for DNA and \(n = 20\) in a protein
GTR matrix.</li>
<li><code>fixed(</code> \(x_1,x_2, \ldots, x_n\) <code>)</code> <br  />
fixed values are assigned to the state frequencies and not
changed during MCMC sampling. \(x_i\) can be expressed as
relative rates (i.e., if the sum is \(\geq 1\), ExaBayes does the
normalizing for you)</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">6.2.6</span> Amino Acid Model Prior</h4>
<div class="outline-text-4" id="text-6-2-6">
<p>
keyword: <code>aaPr</code>, <br  />
default: <code>aaPr disc(remainder=1.0)</code> <br  />
valid values: <br  />
</p>
<ul class="org-ul">
<li><p>
<code>disc(</code> \(m_1\) = \(w_1\), \(m_2\) = \(w_2\), \(\ldots\), \(m_n\) = \(w_n\) <code>)</code>  <br  />
a discrete probability distribution assigning weights \(w_i\) to
protein substitution matrices \(m_i\). If only one model is
specified, this is equivalent to a fixed prior.
</p>

<p>
\(m\) may be one of the following models: DAYHOFF, DCMUT, JTT,
MTREV, WAG, RTREV, CPREV, VT, BLOSUM62, MTMAM, LG, MTART,
MTZOA, PMB, HIVB, HIVW, JTTDCMUT, FLU.
</p>

<p>
By default, if a model is not mentioned in the list, then its
prior probability is 0 and thus is not considered during MCMC
sampling.
</p>

<p>
Additionally, you can include remainder value (i.e.,
<code>remainder=</code> \(w_i\)). This means that all matrices not mentioned
have a prior probability of \(w_i\).
</p></li>
<li><code>fixed(</code> \(m\) <code>)</code><br  />
fix the value of the parameter to one of the models listed above</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27"><span class="section-number-3">6.3</span> Configuring the Run</h3>
<div class="outline-text-3" id="text-6-3">
<p>
All of the following options need to be enclosed within a block
featuring the keyword <code>run</code>. 
</p>
</div>

<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24"><span class="section-number-4">6.3.1</span> General Options</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
The following options allow you to exactly configure what kind of
Bayesian sampling is performed. Keywords and default values are
mentioned along the description of the options.  
</p>

<p>
The most important settings are, how many independent runs
(<b>numRuns</b>, default: 1) you want to run for how many generations
(<b>numGen</b>, default: 1,000,000). If you execute exactly 1 run, then
ExaBayes will terminate after <code>numGen</code> generations. For more than 1
run, ExaBayes will terminate once <code>numGen</code> generations have passed
and one of the following topological convergence diagnostics are
below a specified threshold.
</p>

<p>
By default, ExaBayes draws a sample from every cold chain (i.e.,
for each independent run) every 500 generations (can be changed
via <b>samplingFreq</b>). To change the print frequency (informing you
about the likelihood state of each chain), modify <b>printFreq</b>. 
</p>

<p>
ExaBayes updates a checkpoint file at regular intervals (1,000
generations by default), the respective variable for changing the
frequency is <b>checkPointInterval</b>. 
</p>

<p>
By default, ExaBayes starts from a random-order addition parsimony
tree. If you want to start from a purely random topology, set
<b>parsimonyStart</b> to <code>false</code>.
</p>

<p>
Some proposals (e.g., the branch length multiplier) can be tuned
for achieving good acceptance ratios. ExaBayes tunes proposal
parameters, once a proposal has been drawn 100 times (use
<b>tuneFreq</b> to change this, set it to 0 to disable tuning).
</p>

<p>
If you are running a dataset in parallel that comprises many
partitions, it is advisable to group the proposals per partition
into proposal sets (i.e., set <b>proposalSets</b> to <code>true</code>, this is
the default). If proposal sets are enabled and you have for
instance multiple substitution matrix parameters, then ExaBayes
will propose new substitution parameters for each substitution
matrix parameter one after another (instead of only drawing one of
the parameters at random).
</p>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">6.3.2</span> Options regarding convergence</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
ExaBayes implements the same diagnostics for topological
convergence as MrBayes and BEAST. These are either the maximum or
the average deviation of split (i.e., bipartition) frequencies
(MSDSF/ASDSF). By default, ExaBayes employs the ASDSF. You can
change to MSDSF by setting <b>convergenceCriterion</b> to <code>max</code>. For
disabling the convergence detection, set it to <code>none</code>. 
</p>

<p>
The convergence threshold for either of these statistics can be
specified via <b>sdsfConvergence</b> (default: 0.05, i.e., the
respective statistic must be \(\leq 5\%\)). Usually, splits that
exhibit a low posterior probability are excluded from this
statistic, since it is hard to determine their probability
accurately. You can specify the exclusion threshold for the
ASDSF/MSDSF via <b>sdsfIgnoreFreq</b> (default: 0.1, i.e., splits that
do not occur in at least \(10\%\) of the trees of a run are ignored).
</p>

<p>
Also relevant for the convergence statistic is how many samples
are discarded by ExaBayes as burn-in. By default, the initial \(25\%\)
of all sampled trees are discarded (change this via
<b>burninProportion</b>). If you want to use an absolute burn-in,
specify <b>burninGen</b> (e.g., "<code>burninGen 1e4</code>") instead. In this case,
all trees sampled prior to generation 10,000 are discarded.
</p>

<p>
ExaBayes checks for topological convergence once every run has
proceeded by \(5,000\) generations (set the <b>diagFreq</b> variable to
change this value). 
</p>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26"><span class="section-number-4">6.3.3</span> MC3 options</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
If you sample a rough likelihood landscape, you may want to employ
Metropolis-coupled MCMC (MC3, turned off by default). In very
brief terms, this means that a number of heated chains are coupled
to the cold chain (from which samples are drawn).  All coupled
chains attempt to swap their states at regular intervals. Thus,
the cold chain can be enabled to reach regions of the parameter
space (potentially separated by values with low posterior
probability) that are otherwise very unlikely to be sampled.
</p>

<p>
The total number of coupled chains can be specified via
<b>numCoupledChains</b>.  This number includes the cold chain, so if
you want to add three heated chains, "<code>numCoupledChains 4</code>" is the
correct statement.
</p>

<p>
The chains are heated incrementally, so the more chains you added,
the hotter the hottest chain will get. The heat \(\beta\) for the
$i$-th heated chain (where \(i = 0\) for the cold chain) is defined
as
</p>

\begin{equation}
\beta = \frac{1}{ 1 + i \cdot \delta}. 
\end{equation}

<p>
When deciding upon acceptance of a new state, the likelihood and
prior ratio are exponentiated with \(\beta\) (thus increasing the
acceptance probability for heated chains). By default, the heat
constant \(\delta\) is set to 0.1. The value changed by setting the
variable <b>heatFactor</b>. 
</p>

<p>
The expected number of swap attempts between chains per generation
(i.e., after each chain has proceeded this many generations) can
be specified via <b>numSwapPerGen</b> (default: 1). This is a very
important variable that affects both the performance of the MC3
mechanism as well as the your parallel runtime performance (if
applicable).
</p>

<p>
The reason for this is, that an increase of number of coupled
chains will not directly translate into more efficient
sampling. If the number of swap attempts is kept constant, then it
becomes increasingly unlikely that any change is propagated to the
cold chain as you increase the number of heated chains. On the
other side, if you run coupled chains in parallel (-R argument),
then more swapping attempts will lead to increased waiting
times. This is, because processes computing the chain will have to
wait for processes that compute the likelihood of the other chain
involved in a swap attempt.
</p>

<p>
If you want heated chains to start from the same topology
as the cold chain, set <b>heatedChainsUseSame</b> to <code>true</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="proposal-config"><a id="orgheadline28"></a><span class="section-number-3">6.4</span> Configuring Proposals</h3>
<div class="outline-text-3" id="text-proposal-config">
<p>
ExaBayes allows you to configure proposals that are used to move
your chains through the parameter space. For each proposal, a
relative weight governs, how often a specific proposal is
drawn. You can customize your proposal mixture by modifying these
weights. A proposal provides values for a single parameter only, so
a change of the relative weight affects all related proposals.
Specifically the topological proposals are described in detail in
\cite{Lakner2008a}. 
</p>

<p>
Using proposal sets does not change how often a proposal is drawn
relative to runtime (so no modifications are necessary).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">keyword</th>
<th scope="col" class="org-left">full name</th>
<th scope="col" class="org-left">affected parameters</th>
<th scope="col" class="org-right">default weight</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>nodeSlider</b></td>
<td class="org-left">node slider</td>
<td class="org-left">branch lengths</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left"><b>treeLengthMult</b></td>
<td class="org-left">tree length multiplier</td>
<td class="org-left">branch lengths</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left"><b>branchMulti</b></td>
<td class="org-left">multiplier on branch lengths</td>
<td class="org-left">branch lengths</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-left"><b>eTBR</b></td>
<td class="org-left">extending tree bisection and reconnection (eTBR)</td>
<td class="org-left">topology</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left"><b>eSPR</b></td>
<td class="org-left">extending subtree pruning and regrafting (eSPR)</td>
<td class="org-left">topology</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left"><b>parsimonySPR</b></td>
<td class="org-left">parsimony-biased subtree pruning and regrafting</td>
<td class="org-left">topology</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left"><b>stNNI</b></td>
<td class="org-left">stochastic nearest neighbor interchange</td>
<td class="org-left">topology</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left"><b>likeSPR</b></td>
<td class="org-left">a posterior-guided SPR</td>
<td class="org-left">topology</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left"><b>rateHetMulti</b></td>
<td class="org-left">multiplier on \(\alpha\)</td>
<td class="org-left">rate heterogeneity</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left"><b>revMatSlider</b></td>
<td class="org-left">sliding window</td>
<td class="org-left">rev. matrix (DNA,AA)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left"><b>revMatDirichlet</b></td>
<td class="org-left">dirichlet proposal</td>
<td class="org-left">rev. matrix (DNA,AA)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left"><b>RevmatRateDirich</b></td>
<td class="org-left">partial dirichlet proposal</td>
<td class="org-left">rev. matrix (AA)</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left"><b>frequencySlider</b></td>
<td class="org-left">sliding window</td>
<td class="org-left">state frequencies</td>
<td class="org-right">0.5</td>
</tr>

<tr>
<td class="org-left"><b>frequencyDirichlet</b></td>
<td class="org-left">dirichlet proposal</td>
<td class="org-left">state frequencies</td>
<td class="org-right">0.5</td>
</tr>

<tr>
<td class="org-left"><b>aaModelJump</b></td>
<td class="org-left">fixed AA matrix</td>
<td class="org-left">amino acid model</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left"><b>blDistGamma</b></td>
<td class="org-left">Newton-Raphson-based branch length proposal employing a Gamma distribution</td>
<td class="org-left">branch lengths</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-left"><b>blDistWeibull</b></td>
<td class="org-left">Newton-Raphson-based branch length proposal employing a Weibull distribution (not recommended)</td>
<td class="org-left">branch lengths</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Moreover, the behaviour of the topological proposals can be
customized. The eSPR prunes a subtree, follows down a random path
(starting with the original pruning position) and chooses the
current branch as re-grafting position with a certain stopping
probability (keyword: <code>eSprStopProb</code>). In case of the eTBR, the tree
is bisected at a branch and the bisected branch traverses the tree
on both ends as described for the eSPR (keyword for the stopping
probability is <code>eTbrStopProb</code>).
</p>

<p>
The parsimony-biased SPR (parsSPR) move prunes a subtree and
proposes a regraft position proportionally to the parsimony score of
the resulting tree. The parsSPR evaluates the parsimony score for
regrafting positions that are no more than \(n\) steps (keyword:
<code>parsSPRRadius</code>) apart (i.e., it considers branches within a
specified radius for re-insertion). Computing the parsimony score is
extremely fast and parallelized in ExaBayes. If you are dealing with
large trees, consider increasing the radius. It may not increase
mixing, but definitely will reduce the burn-in time and the increase
in runtime should not be problematic. The default value depends on
the logarithm of the number of taxa (a reasonable assumption, if we
do not expect comb-like trees).
</p>

<p>
Similar to MrBayes, parsimony scores are <i>heated</i> (i.e.,
exponentiated) using the value of <code>parsimonyWarp</code>. If this value is
decreased, the probability that trees with low parsimony score are
proposed will get higher.  
</p>

<p>
The posterior-guided SPR move is particularly expensive, since after
pruning, it evaluates all reattachment locations in a radius
(specified by <code>likeSprMaxRadius</code>) and uses a score based on the
posterior to propose a SPR move. How heavily ExaBayes relies on this
score can be quantified with <code>likeSprWrap</code> (e.g., choose a
likeSprWrap = 0.1 or 0.01 to give topological changes that decrease
the posterior by -10 resp. -100 log-units a reasonable chance of
being proposed).
</p>

<p>
<code>moveOptMode</code> allows you to enhance topological proposals by
simultaneously proposing branch lengths along with topology (turned
off by default). Value 1 means that one branch that is remapped by
any NNI/SPR will be proposed. For moveOptMode = 2, all branches that
are traversed by a moving subtree will be proposed. For moveOptMode
= 3, we additionally propose two branches adjacent and for
moveOptMode = 4, adjacent subtrees (e.g., also the root branch of
the moving subtree) will be proposed. By default, the NR-based Gamma
distribution proposal is used, if useMultiplier is <code>true</code>, then a
multiplier is used instead (not recommended).
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">keyword</th>
<th scope="col" class="org-right">default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>eSprStopProb</b></td>
<td class="org-right">0.5</td>
</tr>

<tr>
<td class="org-left"><b>eTbrStopProb</b></td>
<td class="org-right">0.5</td>
</tr>

<tr>
<td class="org-left"><b>parsimonyWarp</b></td>
<td class="org-right">0.10</td>
</tr>

<tr>
<td class="org-left"><b>parsSprRadius</b></td>
<td class="org-right">\(\lfloor 2 \cdot \log(n) \rfloor\)</td>
</tr>

<tr>
<td class="org-left"><b>useMultilier</b></td>
<td class="org-right">false</td>
</tr>

<tr>
<td class="org-left"><b>moveOptMode</b></td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left"><b>likeSprMaxRadius</b></td>
<td class="org-right">\(\lceil \log_2(n) \rceil\)</td>
</tr>

<tr>
<td class="org-left"><b>likeSprWrap</b></td>
<td class="org-right">1.0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-2">
<h2 id="prepost"><a id="orgheadline36"></a><span class="section-number-2">7</span> Pre-/post-processing utilities</h2>
<div class="outline-text-2" id="text-prepost">
<p>
For all utilities, please use the -h option, the documentation is
mostly sufficient to execute the programs. In this section, we
provide additional hints and caveats about employment of these
tools.
</p>
</div>
<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="parser"><a id="orgheadline30"></a><span class="section-number-3">7.1</span> parser</h3>
<div class="outline-text-3" id="text-parser">
<p>
This utility parses an phylip-formatted alignment and creates a
binary representation of this alignment. You either have to
indicate the data type of a single partition alignment (via <code>-m</code>)
or provide a model file via <code>-q</code> (see Section <a href="#partitionfile">9</a>).
</p>

<p>
Parsing large alignment can take a considerable amount of time that
is lost manifold when ExaBayes is executed in parallel.
</p>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="parser"><a id="orgheadline31"></a><span class="section-number-3">7.2</span> postProcParam</h3>
<div class="outline-text-3" id="text-parser">
<p>
This utility can be used to summarize (similar to sump in MrBayes
or the summary statistics in Tracer) all sampled parameters. 
</p>

<p>
This is straight-forward for continuous parameters (such as
substitution rates). If you integrate over fixed protein model
matrices (e.g, WAG, LG,&#x2026;), you are integrating over a discrete
parameter. The output in the ExaBayes_parameters* will list the
respective matrices. In this case, postProcParam will create an
extra column that contains the discrete distribution. 
</p>

<p>
You should check, if all ESS values are greater than 100 and (if
available) PSRF values are close to 1 (&lt; 1.1 is considered good
convergence).
</p>
</div>
</div>


<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32"><span class="section-number-3">7.3</span> sdsf</h3>
<div class="outline-text-3" id="text-7-3">
<p>
This utility computes deviations of split frequencies (either
maximum or average, abbrev. as ASDSF/MSDSF). If you are integrating
over topologies (you usually are), ASDSF/MSDSF are an essential
convergence criterion. Usually an ASDSF of \(0.5-1\%\) is considered
"excellent convergence" and values between \(1-5\%\) are considered to
be acceptable.
</p>

<p>
You will encounter strongest deviations for branches with low
posterior probability.
</p>

<p>
The stand-alone <code>sdsf</code> computes the same result that is also
calculated, if you run multiple independent analysis with
convergence criterion. If you run an exceptionally large analysis
with multiple independent runs and plan on sampling a very large
number of trees, it is recommendable to launch each independent run
as a distinct ExaBayes session. You could have a master-script that
launches the independent runs (to be run for e.g., 2 h), then
checks for convergence and restarts the runs from the respective
checkpoints, if not converged yet. If an immense number of
processes is involved and your cpu-h budget is tight, this saves
you sequential overhead.
</p>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33"><span class="section-number-3">7.4</span> credibleSet</h3>
<div class="outline-text-3" id="text-7-4">
<p>
This utility computes the credible set of topologies (up to a
specified percentile) in one or many tree sets. Use it for
post-analyses of your tree samples. 
</p>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34"><span class="section-number-3">7.5</span> extractBips</h3>
<div class="outline-text-3" id="text-7-5">
<p>
This utility extracts bipartitions (AKA splits or edges) from tree
sets and the branch lengths associated with these
bipartitions. Note that, this utility also examines trivial
bipartitions (these correspond to outer branches in a tree).
</p>

<p>
extractBips produces the following files: 
</p>
<ul class="org-ul">
<li><b>ExaBayes_bipartitions.*</b> lists the smaller partition of a
bipartition (i.e., all taxa omitted are in the complementary
partition) and assigns a unique identifier to the bipartition.</li>

<li><b>ExaBayes_fileNames.*</b> lists the file names of the input topology
files and assigns a for reference in the remaining two files.</li>

<li><b>ExaBayes_bipartitionBranchLengths.*</b> contains all unique branch
lengths samples associated with a specific bipartition in a
specific file. The file id and bipartition id from the previous
two files are used for that.</li>

<li><b>ExaBayes_bipartitionStatistics.*</b> contains summary statistics
for the branch lengths associated with bipartitions (similar to
the output of postProcParam). The ESS value indicates, whether
you have sufficiently sampled the branch length associated with a
branch and the PSRF value can be used to judge, if the samples
from different chains converged against the same
distribution. You have sufficiently sampled a parameter, if the
ESS is &gt; 100 and a PRSF &lt; 1.1 is an indicator of good
convergence.</li>
</ul>

<p>
If a bipartition occurs only in one chain, extractBips will produce
<code>-nan</code>-values.
</p>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35"><span class="section-number-3">7.6</span> consense</h3>
<div class="outline-text-3" id="text-7-6">
<p>
This utility allows to build consensus trees from one or more tree
sets. If computing the consensus tree (specifically the extended MR
consensus) becomes computationally challenging, you may want to
give the parallelized consensus tree algorithm in <a href="https://github.com/stamatak/standard-RAxML">RAxML</a> a try (use
<code>-J MRE</code>).
</p>

<p>
<code>consense</code> will produces two output files (one in Newick format,
one in Nexus format). Nodes are annotated with marginal probability
(i.e., confidence), median, mean and \(5\%/95\%\) quantile values.
</p>

<p>
If you ran analyses with unlinked branch lengths (i.e., you had
multiple partitions with a branch length parameter each), then you
should create one consensus tree for each branch length parameter.
ExaBayes writes one topology file per parameter and per
analysis. So you can consense all files that have a "tree-x" (where
x is the id of the parameter) in their name.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-2">
<h2 id="cluster"><a id="orgheadline45"></a><span class="section-number-2">8</span> ExaBayes on Clusters/Supercomputers</h2>
<div class="outline-text-2" id="text-cluster">
<p>
The striking feature of ExaBayes is its capability to execute
standard analyses on clusters and super-computers efficiently.
This section goes through various aspects worth considering.
</p>

<p>
On clusters you often have to load a MPI module first. If you
downloaded binaries, try to execute ExaBayes using <code>n</code> processes
and using either <code>mpirun</code> or <code>mpiexec</code> as follows:
</p>

<div class="org-src-container">

<pre class="src src-bash">$ mpirun -np n ./exabayes &lt;further args&gt;
</pre>
</div>

<p>
The exact invocation may vary depending on the MPI installation. If
this does not work, make sure you downloaded the corrected package
or consider compiling ExaBayes from source. On clusters, you
usually have to provide a batch script that is committed to the
scheduler.
</p>

<p>
In ExaBayes, you may have several computing nodes working on a
chain in parallel. We refer to the entirety of nodes computing a
chain as <i>parallel unit</i>.
</p>
</div>

<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">8.1</span> TL;DR summary</h3>
<div class="outline-text-3" id="text-8-1">
<p>
In most cases, if you have \(x\) processes available (e.g., 4
machines with each 12 cores \(\Rightarrow\) 48 processes):
</p>

<ul class="org-ul">
<li>if you run \(n\) independent analyses, use <code>-R n</code>.</li>
<li>if you want to run \(m\) coupled chains, check, if ExaBayes becomes
faster, if you increase from <code>-C 1</code> (default) over <code>-C 2</code> to <code>-C 4</code>
up to <code>-C m</code> (often the optimum is 2 or 4). For each increment
(default: 500 generations), ExaBayes prints the time required for
the last increment (use this for benchmarking).</li>
<li>check the load balance output. For good parallel efficiency, each
process should at least have &asymp; 100 patterns. Otherwise,
less processes may be sufficient, but more do not hurt, if you
are not under a budget constraint.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-3">
<h3 id="right-parallelism"><a id="orgheadline41"></a><span class="section-number-3">8.2</span> Choosing the right kind of parallelism</h3>
<div class="outline-text-3" id="text-right-parallelism">
<p>
ExaBayes implements three levels of parallelism (in descending
order of granularity):
</p>
<ul class="org-ul">
<li>runs-level parallelism,</li>
<li>chain-level parallelism,</li>
<li>data parallelism.</li>
</ul>

<p>
For optimal performance, please consider the following
example. Assume, you run \(m\) coupled chains and \(n\) independent
runs, while you specify that \(m_p\) coupled chains and \(n_p\)
independent runs are run in parallel (via <code>-R</code> and <code>-C</code>). For
reasons of load balance, \(m\) should be a multiple of \(m_p\) (analog
for \(n\)). Assume each of your computing nodes has \(k\) cores and you
want to use \(l\) computing nodes for each parallel working unit
(working on one coupled chain in an independent run that is
executed in parallel). Thus, you will obtain optimal performance,
if you execute ExeBayes with a total number of processes of 
</p>

\begin{equation}
processes = m_p \cdot n_p \cdot l \cdot k .
\end{equation}

<p>
If the number of cores \(k\) is divisible by 2, \(l = 2^i\) (where \(i <
   0\)) works as well. This way several parallel working units fit on a
node.
</p>
</div>

<div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38"><span class="section-number-4">8.2.1</span> On Run-level Parallelism</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
Obviously, run-level parallelism is the most efficient kind of
parallelism. Processes working on different runs rarely have to
communicate with each other (except for writing a checkpoint, so
make sure your checkpointing frequency is not too low).  If you
instruct ExaBayes to execute 2 runs parallel, then using twice as
many processes should result in an optimal speedup of two.
</p>

<p>
Alternatively, you can commit each independent run separately to
the cluster and naturally get the same parallel speedup this
way. You will save computational time, if you regularly check for
topological convergence (using the <code>sdsf</code> tool). So one possibility
is to commit several runs for which you specify a large number of
generations in the config file and a relatively short walltime
(maybe 2h). After the scripts have finished, another script checks
the ASDSF and recommits the runs (using the checkpointing
functionality <code>-r</code>). Or you could commit several jobs for each of
your run and each job has to wait for the previous job to finish
(e.g., using <code>-hold_jid</code> with Grid Engine).
</p>

<p>
The optimal strategy depends on the configuration of your
cluster/supercomputer. In some instances a single large run
parallelized via <code>-R</code> allows your job a higher priority in the
queue, in other instances smaller jobs that run for a short period
will allow you to get the results as quickly as possible.
</p>

<p>
If you sample an immense number of trees using an immense number of
processes, we recommend to choose a non-monolithic (e.g., the
second) strategy. The <code>sdsf</code> requires a bit of runtime on its own
that increases with the number of trees and that is lost manifold,
if many processes have to wait before they continue.
</p>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="chain-level"><a id="orgheadline39"></a><span class="section-number-4">8.2.2</span> On Chain-level Parallelism</h4>
<div class="outline-text-4" id="text-chain-level">
<p>
Employing chain-level parallelism in Bayesian analyses comes with
some caveats. The speedup you can achieve with coupled chains
strongly depends on how often an individual coupled chain is
involved in a swapping attempt. Each time two chains \(a\) and \(b\)
swap, all processes working on \(a\) have to wait for chain \(b\) to
reach the respective generation and vice versa. Reducing the
number of swap attempts (via <code>numSwapPerGen</code>) will improve your
parallel efficiency, but probably reduces your mixing between
coupled chains (e.g., it is less likely that the cold chain
benefits from the hotter ones).
</p>

<p>
So while runtime efficiency probably is the weakest argument for
employing chain-level parallelism, memory is a point to consider
(also see section <a href="#memory">8.3</a>). Likelihood computation is the single
dominating factor of memory consumption. The formula for computing
memory requirements (in Byte) of a single chain in one run is
</p>

\begin{equation}
mem = 4 \cdot 8 \cdot r \cdot p \cdot (n-2),
\end{equation}
<p>
where \(r\) is 4 for DNA and 20 for AA data, \(p\) is the number of
unique site patterns in your alignment and \(n\) is the number of
taxa.
</p>

<p>
For executing \(m\) coupled chains (efficiently), you require \(m+1\)
sets of likelihood arrays, thus \(mem \cdot (m+1)\) byte. Even if
data parallelism is favorable for your dataset, memory
requirements may become prohibitive.  If you employ more
processes, you will also increase the amount of memory that is at
your disposal. However, depending on the size of your dataset,
parallel efficiency of data parallelism will decrease at some
point. This is where chain-level parallelism should be considered.
</p>

<p>
Using chain-level will allow you to increase the number of
processes, while still enough work load is assigned to each
process. 
</p>

<p>
As described above you need an additional set of likelihood
arrays. Unfortunately, this rule still holds, when chain-level
parallelism is employed. Assuming, you run \(m_p\) coupled chains in
parallel, you will need \(mem \cdot (m+m_p)\) byte. For a discussion
on how to reduce \(m_p\), please see Section <a href="#memory">8.3</a>.    
</p>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-4">
<h4 id="data-para"><a id="orgheadline40"></a><span class="section-number-4">8.2.3</span> On Data Parallelism</h4>
<div class="outline-text-4" id="text-data-para">
<p>
Data parallelism means that the unique site patterns of your
alignment are spread out across processes. As discussed at the
beginning of this section you should choose the number of
processes such that the processes involved in computing the
likelihood of a single tree are distributed across as few
computing nodes as possible.
</p>

<p>
Since it takes longer to compute the likelihood of a larger
pattern (i.e., your alignment contains more taxa), it is hard to
say until which point data parallelism can be employed
efficiently. As a rule of thumb each process should at least be
responsible for at least 100 sites. If a parallel run of ExaBayes
is started, ExaBayes prints the load distribution (i.e., how many
pattern are assigned to each process) before starting the
computation.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline42" class="outline-3">
<h3 id="memory"><a id="orgheadline42"></a><span class="section-number-3">8.3</span> Saving Memory</h3>
<div class="outline-text-3" id="text-memory">
<p>
As mentioned earlier, with ExaBayes you can do Bayesian MCMC on
alignments of which the size is only limited by the total memory
you have available in your computing center.
</p>

<p>
In addition to that, ExaBayes implements techniques to reduce the
overall memory footprint. 
</p>

<p>
The <code>-M x</code> option allows you to trade runtime for reduced memory
consumption. The higher <code>x</code>, the slower but less memory-intensive
are the likelihood computations. Remember, that for any <code>-M x</code>
ExaBayes will yield the exact same results with the limitations
described in section <a href="#reproducibility">8.5</a>.
</p>


<p>
This is particularly relevant, if you use chain-level parallelism,
since increased parallelism also increases the memory-overhead as
explained in section <a href="#chain-level">8.2.2</a>. Recall that for <code>x=0</code>, you need
the \((m+m_p)\) sets of likelihood arrays (where <code>m</code> is the number of
coupled chains and \(m_p\) the number of coupled chains executed in
parallel). This is, because ExaBayes uses an additional set of
likelihood arrays to evaluate the likelihood of a new proposal and
saves the previous likelihood arrays for the case of rejection of
the proposal.
</p>

<p>
With <code>-M 1</code>, you can instruct ExaBayes to not save likelihood
arrays for arrays for inner nodes that are (recursively) computed
from two leave (resp. tip) nodes. These nodes are particularly fast
to compute, so you will not loose too much runtime. For a balanced
binary tree (best case), the memory consumption of the saved
likelihood arrays (adding the \(m_p\) to the equation of memory
consumption) is reduced by more than \(50\%\). In the worst case (a
comb-/caterpillar-like tree), the memory consumption is merely
reduced by 1 array.
</p>

<p>
When run with <code>-M 2</code>, ExaBayes will only save likelihood arrays for
the most expensive kind of nodes. These are nodes that have two
inner nodes as their descendants. In terms of memory consumption, a
balanced binary tree is the worst case (saving only \(> 50\%\) of the
additional likelihood arrays). In the best case (here the comb-like
tree), ExaBayes will not save any addition likelihood arrays.
</p>

<p>
For <code>-M 3</code>, ExaBayes by default does not save any likelihood
arrays. The run will be executed substantially slower (but still
less than a factor of 2), but specifically if you run a lot of
chains in parallel, the factor \((m + m_p)\) in the memory
consumption formula is reduced to <code>m</code>.
</p>

<p>
Aside from that, ExaBayes implements a subtree equality
vector-technique, that allows you to save memory for dataset that
contain many gaps or undetermined characters (see
\cite{Izquierdo-Carrasco2011}). The amount of memory you save is
proportional to the amount of missing data and the runtime penalty
should be negligible (resp., there are instances where this
actually increases runtime performance).
</p>
</div>
</div>

<div id="outline-container-orgheadline43" class="outline-3">
<h3 id="orgheadline43"><span class="section-number-3">8.4</span> Highly Partitioned Runs</h3>
<div class="outline-text-3" id="text-8-4">
<p>
In a parallel setting, it is less straight-forward to efficiently
execute an analysis, if the alignment is highly partitioned. The
issue of load distribution in case of data parallelism is discussed
in section <a href="#data-para">8.2.3</a>. The upshot is that you should, whether all
processes of a parallel unit have about the same portion of the
overall data. In parallel runs, ExaBayes initially lists, how many
characters, partitions, (coupled) chains and runs are assigned to
each processor.  For efficiency it is important that the option
<code>proposalSets</code> is by default set to <code>true</code> (default).
</p>

<p>
For assigning data (possibly a huge number of partitions) to
processors, ExaBayes employs the same algorithm as
ExaML \cite{kobert2014divisible}.
</p>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-3">
<h3 id="reproducibility"><a id="orgheadline44"></a><span class="section-number-3">8.5</span> Note on Reproducibility</h3>
<div class="outline-text-3" id="text-reproducibility">
<p>
ExaBayes comes with a strong guarantee of reproducibility.
</p>

<p>
Ideally, the same seed, configuration file and alignment file have
to result in the exact same outcome (e.g., topology/parameter
samples) regardless whether <code>yggdrasil</code> or <code>exabayes</code> were
employed. This should hold for any kind of command line parameter
governing the specifics of how calculations are to be
performed. Furthermore, repeated continuations from a checkpoint
file should not influence the output either.
</p>

<p>
Any change in the configuration file potentially interferes with
perfect reproducibility (e.g., increasing the checkpoint frequency).
</p>

<p>
When parallelism is involved, this guarantee does not hold
necessarily. The reason for this is indeterminism in the calculation
of the likelihood, when conducted on multiple
processors. Compensating for this problem comes at the cost of
runtime performance, thus this has not been implement in ExaBayes. 
</p>

<p>
In other words: running ExaBayes with a different number of
processes theoretically may yield different results (however, we
have not observed this for any MPI implementations yet).
</p>

<p>
All of the above does not influence the correctness of the results,
however it limits the guarantee that the chain is in the exact same
state.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline46" class="outline-2">
<h2 id="partitionfile"><a id="orgheadline46"></a><span class="section-number-2">9</span> File Format: Model/Partitioning file</h2>
<div class="outline-text-2" id="text-partitionfile">
<p>
If you want to partition your data, you have to provide a model file
either to the <code>parser</code> utility or to <code>yggdrasil/exabayes</code> (via
<code>-q</code>). In brief, this format is identical to the raxml model-file
format, except that instead of specifying specific protein
substitution matrices, you must identify a protein partition with
<b>PROT</b> instead of a matrix name such as <b>LG</b>. 
</p>

<p>
The example file below demonstrates the syntax of this file format: 
</p>

<div class="org-src-container">

<pre class="src src-TEXT">DNA, gene1=1-300
DNA, gene2-codonPos1=301-500/3
DNA, gene2-codonPos2=302-500/3
DNA, gene2-codonPos3=303-500/3
PROT, protId=501-800
DNA, composit=801-1000,1101-1200
DNA, gene3=1000-1100
</pre>
</div>

<p>
The bottom line is: 
</p>
<ul class="org-ul">
<li>data type identifier: <b>DNA</b> or <b>PROT</b> (followed by comma)</li>
<li>partitionName (followed by equal sign)</li>
<li>alignment positions:
<ul class="org-ul">
<li>range component, see "gene1"</li>
<li>strided range (useful for codon positions), see
"gene2-codonPos1", "gene2-codonPos2" and "gene2-codonPos3". Notice
that the starting position of the range is incremented for the
second and third codon position.</li>
<li>combining elements, see "composit". You can combine any
element using a comma.</li>
</ul></li>
</ul>

<p>
For concatenating a large number of alignments efficiently, we
distribute this <a href="https://github.com/aberer/concat-aln">tool</a> separately from ExaBayes. It automatically
creates the appropriate model file, although you will have to
manually set the data type for amino acid partitions. Please use
with caution.
</p>

<p>
A side note on efficiency: partitioning your data makes likelihood
calculation less efficient. If for instance you partition your data
and link all parameters across all partitions, then you could have
provided an unpartitioned alignment and the MCMC sampling would
require less computational resources. 
</p>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-2">
<h2 id="orgheadline47"><span class="section-number-2">10</span> Trading mixing efficiency versus runtime</h2>
<div class="outline-text-2" id="text-10">
<p>
As of version 1.4, ExaBayes comes with more advanced guided
proposals that have considerable runtime requirements. If you have
trouble achieving convergence on your dataset, you may want to
increase the usage of these expensive proposals. On the other hand,
if you find your dataset to be easily resolvable and you want as
many samples from your runtime as possible, you may want to switch
to cheaper proposals. Here, we explain your options for both cases
(see Section <a href="#proposal-config">6.4</a> for information on how to configure
proposals).
</p>

<p>
In certain cases, we have observed that the NR-based Gamma proposal
(<code>blDistGamma</code>) increases the probability that chains get stuck
(specifically, if started from a random tree). Here, it may be
useful to run ExaBayes with the default branch length proposal
configuration of version 1.3 (branch length multiplier with weight
15, node slider with weight 5, <code>blDistGamma</code> with weight 0).
</p>

<p>
Currently, the posterior-guided SPR (<code>likeSPR</code>) has a rather low
weight, because of its excessive runtime costs. If runtime is not a
problem, we recommend to increase the weight of this proposal on
hard datasets. For instance, you may want to go for a configuration
that only uses the parsimony-guided SPR and the posterior-guided
SPR, both with weight 10 (list remainder topology proposals and set
its weight to 0). This setting allowed us to resolve hard datasets
with up to 500 taxa which could not be resolved with the previously
implemented proposals. The radius of the posterior-guided SPR is an
important factor concerning runtime/mixing efficiency. In principle
it suffices to set it as large as the largest SPR move that you
expect (e.g., assume you know that an unstable subtree usually has
regrafting locations in a radius of 3 around the pruning
location). Radii should be chosen based upon the dual logarithm of
the number of taxa in your tree (start out with this value and
modify).
</p>

<p>
You may want to turn the posterior-guided SPR off and switch back to
default config from ExaBayes 1.3. For doing so, enable the <code>eTBR</code>,
<code>eSPR</code>, <code>stNNI</code> and <code>parsSPR</code> and assign a weight of 5 to them (0
for <code>likeSPR</code>). We specifically do not recommend the <code>eTBR</code>, since
true TBR moves (that are not actually SPR or NNI moves) are rarely
accepted.
</p>

<p>
Proposing branch lengths simultaneously with topology (<code>moveOptode</code>
&gt; 0 ) may in some cases increase convergence behavior and may allow
extremely accurate estimates of split posterior
probabilities. However, specifically in the presence of a
posterior-guided SPR move, this option becomes very expensive (and
thus the radius for the <code>likeSPR</code> should be chosen conservatively).
</p>

<p>
A cheap option to decrease burn-in time and potentially to increase
mixing efficiency is to increase the radius of the parsimony guided
SPR. Since, computing the parsimony score is very cheap, you do not
have to expect considerable runtime penalties for using arbitrarily
high values here (generally recommended).
</p>
</div>
</div>

<div id="outline-container-orgheadline48" class="outline-2">
<h2 id="orgheadline48"><span class="section-number-2">11</span> Citation</h2>
<div class="outline-text-2" id="text-11">
<p>
ExaBayes has been published in <a href="http://mbe.oxfordjournals.org/content/early/2014/08/16/molbev.msu236.abstract">Molecular Biology and Evolution</a>.
</p>

<p>
The respective BibTex entry for citing the advance online
publication is:
</p>

<div class="org-src-container">

<pre class="src src-TEXT">@article{aberer2014exabayes,
  title={ExaBayes: Massively Parallel Bayesian Tree Inference for 
  the Whole-Genome Era},
  author={Aberer, Andre J and Kobert, Kassian and Stamatakis, Alexandros},
  journal={Molecular Biology and Evolution},
  pages={msu236},
  year={2014},
  publisher={Oxford University Press}
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline49" class="outline-2">
<h2 id="orgheadline49"><span class="section-number-2">12</span> References</h2>
<div class="outline-text-2" id="text-12">
<iframe width="100%" src="library2.html"></iframe>

<hr  />
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: for support, please contact exabayes-at-googlegroups-dot-com</p>
<p class="date">Created: 2016-09-24 Sa 13:28</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
